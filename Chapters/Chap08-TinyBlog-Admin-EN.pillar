!! Administration Web Interface and Automatic Form Generation

We will now develop the administration part of TinyBlog.
In previous chapter, we define Seaside components that interact together and where each component
is responsible for its internal state, behavior and its graphical rendering. 

In this chapter, we want to show that we can go a step further and generate Seaside components from object descriptions
using the Magritte framework.

Figure *@RapportNewLookActions2* shows a part of the result we will obtain,  the other part being post edition.

+Post managment.>file://figures/RapportNewLookActions.png|width=75|label=RapportNewLookActions2+

Figure *@ApplicationAdmin* shows a survey of the architecture that we will develop in this chapter.

+Administration components.>file://figures/ApplicationArchitectureWithAdmin.pdf|width=75|label=ApplicationAdmin+

!!!Describing Domain DataDécrire les données métiers avec Magritte

Magritte is a library that allows one to generate various representations once the objects are described. 
Coupled with Seaside, Magritte generates forms and reports.
The Quuve of the Debris Publishing company
is a brillant example of Magritte power: all tables and reports are automatically generated (see *http://www.pharo.org/success*).

Data validation is also done at the Magritte level instead of being dispersed in the user interface code. 
This chapter will not cover such aspects. Resources on Magritte are a chapter in the Seaside book 
 (*http://book.seaside.st*) as well as a tutorial under writing available at *https://github.com/SquareBracketAssociates/Magritte*.

A description is an object that specifies information on the datat of our model as well as its type, whether the information 
is mandatory, if it should be sorted and what is the default value. 

!!!Post Description

Let us start to describe the five instance variable of ==TBPost== with Magritte.
Then we will show how we can get a form generated for us. 

We will define the five following methods in the protocol 'magritte-descriptions' of the class ==TBPost==.
Note that the method names are not important but we follow a convention. 
This is the pragma ==<magritteDescription>== (method annotation) that allows Magritte to identify 
descriptions. 

The post title is a string of characters that is mandatory.

[[[
TBPost >> descriptionTitle
   <magritteDescription>
   ^ MAStringDescription new
      accessor: #title;
      beRequired;
      yourself
]]]

A post test is a multi-line that is mandatory.


[[[
TBPost >> descriptionText
   <magritteDescription>
   ^ MAMemoDescription new
      accessor: #text;
      beRequired;
      yourself
]]]

The category is represented as a string and it does not have to be given. In such case 
the post will be sorted in the 'Unclassified' category.

[[[
TBPost >> descriptionCategory
   <magritteDescription>
   ^ MAStringDescription new
      accessor: #category;
      yourself
]]]

The post creation time is important since it is used to sort posts. 
It is then required. 

[[[
TBPost >> descriptionDate
   <magritteDescription>
   ^ MADateDescription new
      accessor: #date;
      beRequired;
      yourself
]]]

The visible instance variable should be a Boolean and it is required.

[[[
TBPost >> descriptionVisible
   <magritteDescription>
   ^ MABooleanDescription new
      accessor: #visible;
      beRequired;
      yourself
]]]

We could enrich the descriptions so that it is not possible to publish a post with a date before the current day. 
We could change the description of a category to make sure that a category is part of a predefined list of categories. 
We do not do it to keep it to the main point. 


!!! Automatic Component Creation

Once a post described we can  generate a Seaside component by sending a message ==asComponent== to an post instance.

[[[
aTBPost asComponent
]]]

Let us see how we can use this in the following.


!!! Building a post report 

We will develop a new component that will be used by the component  ==TBAdminComponent==.
The  ==TBPostReport== component is a report that will contain all the posts.
As we will see below the report Seaside component will be generated automatically from Magritte.
We could have develop only one component but we prefer to distinguish it from the admin component for future evolution. 

!!!! The PostsReport Component

Post list is displayed using a report dynamically generated by Magritte. 
We will use Magritte to implement the different behavio of the admin activity (post list, post creation, edition, delete of a post).

The component ==TBPostsReport== is a subclass of 
==TBSMagritteReport== that manages reports with Bootstrap.

[[[
TBSMagritteReport subclass: #TBPostsReport
   instanceVariableNames: ''
   classVariableNames: ''
   package: 'TinyBlog-Components'
]]]

We add a creation method that takes a blog as argument.

[[[
TBPostsReport class >> from: aBlog
   | allBlogs |
   allBlogs := aBlog allBlogPosts.
   ^ self rows: allBlogs description: allBlogs anyOne magritteDescription
]]]

!!!  AdminComponent Integration with PostsReport

Let us now revise our ==TBAdminComponent== to display this report. 

We add an instance variable ==report== and its accessors in the class ==TBAdminComponent==.

[[[
TBScreenComponent subclass: #TBAdminComponent
	instanceVariableNames: 'report'
	classVariableNames: ''
	package: 'TinyBlog-Components'
]]]

[[[
TBAdminComponent >> report
   ^ report
]]]

[[[
TBAdminComponent >> report: aReport
   report := aReport
]]]

Since the report is a son component of  the admin component we should not forget to redefine the method ==children==.
Note that the collection contains the subcomponents defined in the superclass (header component) and those
in current class (report component).

[[[
TBAdminComponent >> children
   ^ super children copyWith: self report
]]]

In ==initialize== method we instantiate a report by giving it a blog instance.

[[[
TBAdminComponent >> initialize
   super initialize.
   self report: (TBPostsReport from: self blog)
]]]

Let us modify the admin part rendering to display the report. 

[[[
TBAdminComponent >> renderContentOn: html
   super renderContentOn: html.
   html tbsContainer: [
      html heading: 'Blog Admin'.
      html horizontalRule.
      html render: self report ]
]]]

You can test this change by refreshing your web browser.


!!! Filter Columns

By default, a report displays the full data of each post. 
However, some columns are not useful 
We should filter the columns. 
Here we only keep the title, category and publication date.

We add a class method for the column selection and modifier the method ==from:== to use this.

[[[
TBPostsReport class >> filteredDescriptionsFrom: aBlogPost
	"Filter only some descriptions for the report columns."

	^ aBlogPost magritteDescription
		select: [ :each | #(title category date) includes: each accessor selector ]
]]]

[[[
TBPostsReport class >> from: aBlog
   | allBlogs |
   allBlogs := aBlog allBlogPosts.
   ^ self rows: allBlogs description: (self filteredDescriptionsFrom: allBlogs anyOne)
]]]


Figure *@RapportV1* shows the situation that you should get.

+Magritte report with posts.>file://figures/RapportMagritteV1.png|width=100|label=RapportV1+


!!! Report Enhancements

The previous report is pretty raw. 
There is no title on columns and the display column order is not fixed. 
This can change from one instance to the other. 
To handle this, we modify the description for each instance variable. 
We specify a priority and a title  (message ==label:==) as follows: 

[[[
TBPost >> descriptionTitle
   <magritteDescription>
   ^ MAStringDescription new
      label: 'Title';
      priority: 100;
      accessor: #title;
      beRequired;
      yourself
]]]

[[[
TBPost >> descriptionText
   <magritteDescription>
   ^ MAMemoDescription new
      label: 'Text';
      priority: 200;
      accessor: #text;
      beRequired;
      yourself
]]]

[[[
TBPost >> descriptionCategory
   <magritteDescription>
   ^ MAStringDescription new
      label: 'Category';
      priority: 300;
      accessor: #category;
      yourself
]]]

[[[
TBPost >> descriptionDate
   <magritteDescription>
   ^ MADateDescription new
      label: 'Date';
      priority: 400;
      accessor: #date;
      beRequired;
      yourself
]]]

[[[
TBPost >> descriptionVisible
   <magritteDescription>
   ^ MABooleanDescription new
      label: 'Visible';
      priority: 500;
      accessor: #visible;
      beRequired;
      yourself
]]]

You should obtain the situation such as represented by Figure *@adminReportDraft*.
+Administration Report.>file://figures/RapportMagritteV2.png|width=85|label=adminReportDraft+


!!!Post Administration

We can now put in place a CRUD (Create Read Update Delete) allowing to generate posts.
For this, we will add a new column (instance of ==MACommandColumn==) to the report.  
This column will group the different operations using the ==addCommandOn:== message. 
This method allows one to define a link that will execute a method of the current object. 
We give access to the blog the report is build for.

[[[
TBSMagritteReport subclass: #TBPostsReport
    instanceVariableNames: 'blog'
    classVariableNames: ''
    package: 'TinyBlog-Components'
]]]

[[[
TBSMagritteReport >> blog
   ^ blog
]]]

[[[
TBSMagritteReport >> blog: aTBBlog
   blog := aTBBlog
]]]

The method  ==from:== adds a new column to the report. It groups the different operations. 

[[[
TBPostsReport class >> from: aBlog
    | report blogPosts |
    blogPosts := aBlog allBlogPosts.
    report := self rows: blogPosts description: (self filteredDescriptionsFrom: blogPosts anyOne).
    report blog: aBlog.
    report addColumn: (MACommandColumn new
        addCommandOn: report selector: #viewPost: text: 'View'; yourself;
        addCommandOn: report selector: #editPost: text: 'Edit'; yourself;
        addCommandOn: report selector: #deletePost: text: 'Delete'; yourself).
     ^ report
]]]


Nous allons devoir définir les méthodes liées à chaque opérations dans une prochaine section.

Par ailleurs, cette méthode est un peu longue et elle ne permet pas de separer la définition du rapport de l'ajout d'opérations sur les éléments. Une solution est de créer une méthode d'instance ==addCommands== et de l'appeller explicitement.  Faites cette transformation.



!!! Gérer l'ajout d'un bulletin

L'ajout (add) est dissocié des bulletins et se trouvera donc juste avant le rapport. 
Etant donné qu'il fait partie du composant ==TBPostsReport==, nous devons redéfinir la méthode ==renderContentOn:== du composant ==TBPostsReport== pour insérer le lien ==add==.


[[[
TBPostsReport >> renderContentOn: html
   html tbsGlyphIcon iconPencil.
   html anchor
      callback: [ self addPost ];
      with: 'Add post'.
   super renderContentOn: html
]]]

Identifiez-vous à nouveau et vous devez obtenir la situation telle que représentée par la figure *@RapportNewLookActions*.
+Rapport des bulletins avec des liens d'édition.>file://figures/RapportNewLookActions.png|width=75|label=RapportNewLookActions+


!!! Implémentation des actions CRUD

A chaque action (Create/Read/Update/Delete) correspond une méthode de l'objet ==TBPostsReport==. 
Nous allons maintenant les implémenter. 
Un formulaire personnalisé est construit en fonction de l'opération demandé (il n'est pas utile par exemple d'avoir un bouton "Sauver" alors que l'utilisateur veut simplement lire le post).

!!!Ajouter un bulletin
Commençons par gérer l'ajout d'un bulletin.
La méthode ==renderAddPostForm:== suivante illustre la puissance de Magritte pour générer des formulaires.

[[[
TBPostsReport >> renderAddPostForm: aPost
    ^ aPost asComponent
        addDecoration: (TBSMagritteFormDecoration buttons: { #save -> 'Add post' .  #cancel -> 'Cancel'});
        yourself
]]]

Ici, le message ==asComponent==, envoyé à un objet métier instance de la classe ==TBPost==, créé directement un composant Seaside. Nous ajoutons une décoration à ce composant Seaside afin de gérer ok/cancel.


La méthode ==addPost== pour sa part, affiche le composant rendu par la méthode ==renderAddPostForm:== et lorsque qu'un nouveau post est créé, elle l'ajoute au blog. La méthode ==writeBlogPost:== sauve les changements.

[[[
TBPostsReport >> addPost
    | post |
    post := self call: (self renderAddPostForm: TBPost new).
    post ifNotNil: [ blog writeBlogPost: post ]
]]]

 On voit une fois encore l'utilisation du message ==call:== pour donner la main à un composant.
Le lien pour ajouter un bulletin permet maintenant d'afficher un formulaire de création que nous rendrons plus présentable (Voir figure *@AffichePostRaw*).


+Affichage rudimentaire d'un bulletin.>file://figures/AffichePostRaw.png|width=75|label=AffichePostRaw+



!!!!Afficher un bulletin
Pour afficher un bulletin en lecture nous définissons deux méthodes similaires aux précédentes.
Notez que nous utilisons l'expression ==readonly: true== pour indiquer que le formulaire n'est pas éditable.

[[[
TBPostsReport >> renderViewPostForm: aPost
   ^ aPost asComponent 
       addDecoration: (TBSMagritteFormDecoration buttons: { #cancel -> 'Back' });
       readonly: true;
       yourself
]]]

Voir un bulletin ne nécessite pas d'action supplémentaire que d'afficher le composant.
[[[
TBPostsReport >> viewPost: aPost
   self call: (self renderViewPostForm: aPost)
]]]

!!!!Editer un bulletin

Pour éditer un bulletin nous utilisons la même approche. 
[[[
TBPostsReport >> renderEditPostForm: aPost
   ^ aPost asComponent addDecoration: (
      TBSMagritteFormDecoration buttons: {
         #save -> 'Save post'.
         #cancel -> 'Cancel'});
      yourself
]]]

Maintenant la méthode ==editPost:== récupère la valeur du message ==call:== et sauve les changements apportés.
[[[
TBPostsReport >> editPost: aPost
   | post |
   post := self call: (self renderEditPostForm: aPost).
   post ifNotNil: [ blog save ]
]]]

!!!!Supprimer un bulletin

Il nous faut maintenant ajouter la méthode ==removeBlogPost:== à la classe ==TBBlog==:

[[[
TBBlog >> removeBlogPost: aPost
    posts remove: aPost ifAbsent: [ ].
    self save.
]]]

ainsi qu'un test unitaire :

[[[
TBBlogTest >> testRemoveBlogPost
    self assert: blog size equals: 1.
    blog removeBlogPost: blog allBlogPosts anyOne.
    self assert: blog size equals: 0
]]]

Pour éviter une opération accidentelle, nous utilisons une boite modale pour que l'utilisateur confirme la suppression du post. 
Une fois le post effacé, la liste des posts gérés par le composant ==TBPostsReport== est actualisée et le rapport est rafraîchi.

[[[
TBPostsReport >> deletePost: aPost
    (self confirm: 'Do you want remove this post ?')
        ifTrue: [ blog removeBlogPost: aPost ]
]]]



!!!Gérer le rafraîchissement des données

Les méthodes ==addPost:== et ==deletePost:== font bien leur travail mais les données à l'écran ne sont pas mises à jour.
Il faut donc rafraichir la liste des bulletins car il y a un décalage entre les données en mémoire et celles stockées dans la base de données.

[[[
TBPostsReport >> refreshReport
    self rows: blog allBlogPosts.
    self refresh.
]]]

[[[
TBPostsReport >> addPost
	| post |
	post := self call: (self renderAddPostForm: TBPost new).
	post
		ifNotNil: [ blog writeBlogPost: post.
			self refreshReport ]
]]]

[[[
TBPostsReport >> deletePost: aPost
    (self confirm: 'Do you want remove this post ?')
        ifTrue: [ blog removeBlogPost: aPost.
                 self refreshReport ]
]]]

Le rapport est maintenant fonctionnel  et gère même les contraintes de saisie c'est-à-dire que le formulaire assure par exemple que les champs déclarés comme obligatoire dans les descriptions Magritte sont bien renseignés.

!!!Amélioration de l'apparence des formulaires

Pour tirer parti de Bootstrap, nous allons modifier les définitions Magritte. Tout d'abord, spécifions que le rendu du formulaire doit se baser sur Bootstrap.

Un container en Magritte est l'élément qui va contenir les composants créer à partir des descriptions.

[[[
TBPost >> descriptionContainer
    <magritteContainer>
    ^ super descriptionContainer
        componentRenderer: TBSMagritteFormRenderer;
        yourself
]]]

Nous pouvons maintenant nous occuper des différents champs de saisie et améliorer leur apparence.

[[[
TBPost >> descriptionTitle
    <magritteDescription>
    ^ MAStringDescription new
        label: 'Title';
        priority: 100;
        accessor: #title;
        requiredErrorMessage: 'A blog post must have a title.';
        comment: 'Please enter a title';
        componentClass: TBSMagritteTextInputComponent;
        beRequired;
        yourself
]]]

+Formulaire d'ajout d'un post avec Bootstrap.>file://figures/AddAPostBootstrap.png|width=85|label=addAPostBootstrap+


[[[
TBPost >> descriptionText
    <magritteDescription>
    ^ MAMemoDescription new
        label: 'Text';
        priority: 200;
        accessor: #text;
        beRequired;
        requiredErrorMessage: 'A blog post must contain a text.';
        comment: 'Please enter a text';
        componentClass: TBSMagritteTextAreaComponent;
        yourself
]]]

[[[
TBPost >> descriptionCategory
    <magritteDescription>
    ^ MAStringDescription new
        label: 'Category';
        priority: 300;
        accessor: #category;
        comment: 'Unclassified if empty';
        componentClass: TBSMagritteTextInputComponent;
        yourself
]]]



[[[
TBPost >> descriptionVisible
    <magritteDescription>
    ^ MABooleanDescription new
        checkboxLabel: 'Visible';
        priority: 500;
        accessor: #visible;
        componentClass: TBSMagritteCheckboxComponent;
        beRequired;
        yourself
]]]

Grâce à ces nouvelles descriptions Magritte, les formulaires générés sous la forme de composants Seaside utilisent Bootstrap. 
Par exemple, formulaire d'édition d'un post doit maintenant ressembler à celui de la figure *@addAPostBootstrap*.


!!!Conclusion 

Nous avons mis en place la partie administration de TinyBlog sous la forme d'un rapport des bulletins contenus dans le blog courant. 
Nous avons également ajouté des liens permettant une gestion CRUD de chaque bulletin. 
Nous avons réalisé tout cela en utilisant Magritte. 
En effet, nous avons ajouté des descriptions sur les bulletins et généré des composants Seaside (des formulaires) à partir de ces descriptions.
