!! TinyBlog: Extending and testing the model
@chapModelExtensionAndUnitTests

In this chapter we will extend the model and add more tests.

Note that when you become fluent in Pharo, you will tend to write and execute your tests first, writing the implementation code in the debugger. We have not done this here as coding in the debugger requires a little more explanation. But you can see this practice in the Mooc video  ''Coding a Counter in the Debugger'' (See *http://mooc.pharo.org*), and also learn more in the book ''Learning Object-Oriented Programming, Design with TDD in Pharo'' (*http://books.pharo.org/learning-oop*).

Before starting, make sure you still have the code you wrote in the previous chapter, or use the information in Chapter *@cha:Loading* to load it into your image.

!!! TBBlog class

We will develop the class ==TBBlog== that contains posts (as shown by Figure *@postBlogUml*). We will also write some unit tests.

+TBBlog: A simple class containing posts.>file://figures/postBlogUML.pdf|width=55|label=postBlogUml+

Here is the definition of ==TBBlog==: 

[[[
Object subclass: #TBBlog
   instanceVariableNames: 'posts'
   classVariableNames: ''
   package: 'TinyBlog'
]]]

We initialize the ==posts== instance variable to an empty collection.

[[[
TBBlog >> initialize
   super initialize.
   posts := OrderedCollection new
]]]


!!!Only one blog object

In the rest of this project, we assume that we will manage only ''one'' blog.  Later, you may add the possibility to manage multiple blogs, such as one per user of the TinyBlog application. Currently, we will use the Singleton design pattern for the ==TBBlog== class. But pay attention since this pattern introduces a kind of global variable in your application and brings less modularity to your system.  Therefore you should avoid making explicit references to the singleton; you should prefer to use an instance variable whose value refers to the singleton so that later you can pass another object without being forced to rewrite everything. Do not take what we are doing with this class as an example.

Since the management of a singleton is done through class behavior, we define such methods on the class side of ==TBBlog==. We define an instance variable at the class level: 

[[[
TBBlog class
   instanceVariableNames: 'uniqueInstance'
]]]

Then we define two methods to manage the singleton:

[[[
TBBlog class >> reset
   uniqueInstance := nil
]]]

[[[
TBBlog class >> current
   "answer the instance of the TBBlog"
   ^ uniqueInstance ifNil: [ uniqueInstance := self new ]
]]]

% worth discussing lazy initialization above?

We redefine the class method ==initialize== so that when the class is loaded into memory, the singleton gets reset:

[[[
TBBlog class >> initialize
   self reset
]]]

!!!Testing the model

Now we'll adopt a Test-Driven Development approach, i.e. we will write a unit test first and then develop the functionality until the test passes. We will repeat this process for each new piece of functionality in the model.

We create unit tests in the ==TBBlogTest== class that belongs to the ==TinyBlog-Tests== tag. A tag is just a label to sort classes inside a package (See menu item 'Add Tag...'). We use a tag because using two packages will make this project more complex. However, while implementing a real application, it is recommended to have one (or multiple) separate test packages.

[[[
TestCase subclass: #TBBlogTest
   instanceVariableNames: 'blog post first'
   classVariableNames: ''
   package: 'TinyBlog-Tests'
]]]

Before each test execution, the ==setUp== method initializes the test context (also called test fixture). For example, it erases the blog content, adds one post and creates another temporary post that is not saved.

Pay attention since we will have to modify such behavior in the future else each time we will run the test we will destroy our data. This is an example of the kind of insidious behavior that a singleton introduces.

[[[
TBBlogTest >> setUp
   blog := TBBlog current.
   blog removeAllPosts.

   first := TBPost title: 'A title' text: 'A text' category: 'First Category'.
   blog writeBlogPost: first.

   post := (TBPost title: 'Another title' text: 'Another text' category: 'Second Category') beVisible
]]]

As you can see, we're setting up a couple of posts with different configuration to test the way they behave. The two posts are in different categories, one is visible and the other is not.

At the end of each test, the ==tearDown== method is executed to reset the blog.

[[[
TBBlogTest >> tearDown
   TBBlog reset
]]]

Here we see one of the limits of using a singleton. Indeed, if you deploy a blog and then execute the tests, you will lose all posts that have been created because we reset the Blog singleton. We will address this problem in the future.

We will now write some tests, then implement the memthods to make them pass.

!!!A first test

The first test adds a post in the blog and verifies that this post is added:

[[[
TBBlogTest >> testAddBlogPost
   blog writeBlogPost: post.
   self assert: blog size equals: 2
]]]

This test will fail because we haven't defined the methods ==writeBlogPost:==, ==removeAllPosts== and ==size==. So let's add them:

[[[
TBBlog >> removeAllPosts
   posts := OrderedCollection new
]]]

[[[
TBBlog >> writeBlogPost: aPost
   "Add the blog post to the list of posts."
   posts add: aPost
]]]

[[[
TBBlog >> size
   ^ posts size
]]]

And now the test should pass.

!!!Increasing test coverage

We should also add tests to cover all the other behaviours that we have introduced so far. The following tests should pass as we've already written the necessary code:

[[[
TBBlogTest >> testSize
   self assert: blog size equals: 1
]]]

[[[
TBBlogTest >> testRemoveAllBlogPosts
   blog removeAllPosts.
   self assert: blog size equals: 0
]]]

!!!Other behaviours

As we extend our program, we will continue to follow the test-driven way of defining our program's behaviour: first we write a test, then we verify that the test is failing, then we define any methods we need to make the test pass, and then finally we verify that the test passes.

!!!!All posts 

Let's create a test that fails:

[[[
TBBlogTest >> testAllBlogPosts
   blog writeBlogPost: post.
   self assert: blog allBlogPosts size equals: 2
]]]

And the model code that makes it succeed:

[[[
TBBlog >> allBlogPosts
   ^ posts
]]]

Your test should pass.

!!!!Visible posts

We define a new unit test to test accessing all visible blog posts:

[[[
TBBlogTest >> testAllVisibleBlogPosts
   blog writeBlogPost: post.
   self assert: blog allVisibleBlogPosts size equals: 1
]]]

We add the corresponding method: 

[[[
TBBlog >> allVisibleBlogPosts
   ^ posts select: [ :p | p isVisible ]
]]]

And we verify that the test passes.

!!!!All posts of a category

The following test verifies that we can access all the posts of a given category. Once defined, we should make sure that the test failed.

[[[
TBBlogTest >> testAllBlogPostsFromCategory
   self assert: (blog allBlogPostsFromCategory: 'First Category') size equals: 1
]]]

Then we can define the functionality and make sure that our test passes.

[[[
TBBlog >> allBlogPostsFromCategory: aCategory
   ^ posts select: [ :p | p category = aCategory ]
]]]

Verify that the test passes.

!!!!All visible posts of a category

The following test verifies that we can access all the visible posts of a given category. Once we've written a test, we should always run it to make sure that it fails. A test that is green no matter what we do is meaningless!

[[[
TBBlogTest >> testAllVisibleBlogPostsFromCategory
   blog writeBlogPost: post.
   self assert: (blog allVisibleBlogPostsFromCategory: 'First Category') size equals: 0.
   self assert: (blog allVisibleBlogPostsFromCategory: 'Second Category') size equals: 1
]]]

Then we can define the functionality and make sure that our test passes:

[[[
TBBlog >> allVisibleBlogPostsFromCategory: aCategory
	^ posts select: [ :p | p category = aCategory 
									and: [ p isVisible ] ]
]]]

Make sure the test passes.

!!!!Check unclassified posts

The following test demonstrates that we do not have unclassified blogs in our test fixture. 

[[[
TBBlogTest >> testUnclassifiedBlogPosts
   self assert: (blog allBlogPosts select: [ :p | p isUnclassified ]) size equals: 0
]]]

Verify that the test passes. 

!!!!Retrieve all categories

Again we define a new test and watch it fail:

[[[
TBBlogTest >> testAllCategories
   blog writeBlogPost: post.
   self assert: blog allCategories size equals: 2
]]]

We then add the new behavior.
[[[
TBBlog >> allCategories
   ^ (self allBlogPosts collect: [ :p | p category ]) asSet
]]]

Verify that the test passes. 

!!!Testing data 

To help you test the application, you can add the following method that creates multiple posts.

[[[
TBBlog class >> createDemoPosts
   "TBBlog createDemoPosts"
   self current 
      writeBlogPost: ((TBPost title: 'Welcome in TinyBlog' text: 'TinyBlog is a small blog engine made with Pharo.' category: 'TinyBlog') visible: true);
      writeBlogPost: ((TBPost title: 'Report Pharo Sprint' text: 'Friday, June 12 there was a Pharo sprint / Moose dojo. It was a nice event with more than 15 motivated sprinters. With the help of candies, cakes and chocolate, huge work has been done' category: 'Pharo') visible: true);
      writeBlogPost: ((TBPost title: 'Brick on top of Bloc - Preview' text: 'We are happy to announce the first preview version of Brick, a new widget set created from scratch on top of Bloc. Brick is being developed primarily by Alex Syrel (together with Alain Plantec, Andrei Chis and myself), and the work is sponsored by ESUG. 
      Brick is part of the Glamorous Toolkit effort and will provide the basis for the new versions of the development tools.' category: 'Pharo') visible: true);
      writeBlogPost: ((TBPost title: 'The sad story of unclassified blog posts' text: 'So sad that I can read this.') visible: true);
      writeBlogPost: ((TBPost title: 'Working with Pharo on the Raspberry Pi' text: 'Hardware is getting cheaper and many new small devices like the famous Raspberry Pi provide new computation power that was one once only available on regular desktop computers.' category: 'Pharo') visible: true)
]]]

If you inspect the result of the following snippet, you will see that the current blog contains 5 posts:

[[[
	TBBlog createDemoPosts ; current
]]]

Be aware that if you execute this ==createDemoPosts== method multiple times, your blog singleton object will contain multiple copies of these posts.

!!!Possible extensions

Many extensions can be made such as:

- retrieve the list of categories that contains at least one visible post
- delete a category and all posts that it contains
- rename a category
- move a post from one category to another
- make a category (in)visible and all of its posts

and many more! We encourage you to try and build some of them. 

!!! Conclusion

You now have the full model of TinyBlog as well as some unit tests. You are now ready to implement more advanced functionality such as the database storage or your first web front-end. Do not forget to save your code!
