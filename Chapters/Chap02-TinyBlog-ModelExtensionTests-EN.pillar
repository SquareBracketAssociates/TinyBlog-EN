!! TinyBlog: Extending and testing the model
@chapModelExtensionAndUnitTests

% full hash of full code 35785aaaf1284f1a472980f07522fc7d0d4743e6

In this chapter we extend the model and add more tests. Note that when you will get fluent in Pharo, you will tend to write
first your tests and then execute tests to code in the debugger. We did not do it because coding in the debugger requires 
more explanation. You can see such practice in the Mooc video entitled  ''Coding a Counter in the Debugger'' (*http://rmod-pharo-mooc.lille.inria.fr/MOOC/WebPortal/co/content_26.html*) and read the book ''Learning Object-Oriented Programming, Design with TDD in Pharo'' (*http://books.pharo.org*).

Before starting, use back the code of the previous chapter or use the information of Chapter *@chaLoading*.

% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!!! TBBlog class
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We develop the class ==TBBlog==. It contains posts and its unit tests.

[[[
Object subclass: #TBBlog
   instanceVariableNames: 'posts'
   classVariableNames: ''
   package: 'TinyBlog'
]]]

We initialize the ==posts== instance variable to an empty collection.

[[[
TBBlog >> initialize
   super initialize.
   posts := OrderedCollection new
]]]


!!!Only one blog object

In the rest of this project, we assume that we will manage only one blog. 
Later, you may add the possibility to manage multiple blogs such as one per user of the TinyBlog application. 
Currently, we use a Singleton design pattern on the ==TBBlog== class. 
However pay attention since this pattern introduces a kind of global variable in your application and brings less modularity to your system. 
Therefore avoid to make explicit references to the singleton. 
Do not generalize what we are doing for this class.


Since all the management of a singleton is a class behavior, we define such methods at the class level of ==TBBlog==. 

[[[
TBBlog class
   instanceVariableNames: 'uniqueInstance'
]]]
[[[
TBBlog class >> reset
   uniqueInstance := nil
]]]
[[[
TBBlog class >> current
   "answer the instance of the TBRepository"
   ^ uniqueInstance ifNil: [ uniqueInstance := self new ]
]]]

We redefine the class method ==initialize== so that when the class is loaded in memory
the singleton got reset.

[[[
TBBlog class >> initialize
   self reset
]]]


!!!Testing the model


We now adopt a Test Driven Development approach i.e., we will write a unit test first and then develop the business functionality until the test is green. We will repeat this process for each functionality of the model.

We create unit tests in the ==TBBlogTest== class that belongs to the ==TinyBlog-Tests== tag. A tag is just a label to sort classes inside a package (See menu item 'Add Tag...'). We use a tag because using two packages will make this project more complex. However, while implementing a real application, it is recommended to have a separate package for the tests.

[[[
TestCase subclass: #TBBlogTest
   instanceVariableNames: 'blog post first'
   classVariableNames: ''
   package: 'TinyBlog-Tests'
]]]

Before each test execution, the ==setUp== method initializes the context of tests.
For example, it erases the blog content, adds one post and creates another temporary post that is not saved.

Pay attention since we will have to modify such behavior in the future else each time we will run the test
we will destroy our data. 
This is an example of the kind of bad behavior that a singleton introduces.

[[[
TBBlogTest >> setUp
   blog := TBBlog current.
   blog removeAllPosts.

   first := TBPost title: 'A title' text: 'A text' category: 'First Category'.
   blog writeBlogPost: first.

   post := (TBPost title: 'Another title' text: 'Another text' category: 'Second Category') beVisible
]]]

As you may notice, we test different configurations. 
Posts do not belong to the same category, one is visible and the other is not visible.
At the end of each test, the ==tearDown==  method is executed and resets the blog.

[[[
TBBlogTest >> tearDown
   TBBlog reset
]]]

Here we see the limits of using a Singleton. Indeed, if you deploy a blog and then execute the tests, you will lose all posts that have been created because we reset the Blog singleton. We will address this problem in the future.

We will now develop tests first and then implement all functionalities to make them green.

!!!A first test

The first test adds a post in the blog and verifies that this post is effectivly added.

[[[
TBBlogTest >> testAddBlogPost
   blog writeBlogPost: post.
   self assert: blog size equals: 2
]]]

If you try to execute it, you will notice that this test is not green because we did not define the methods ==writeBlogPost:==, ==removeAllPosts== and ==size==.
Let's add them:

[[[
TBBlog >> removeAllPosts
   posts := OrderedCollection new
]]]

[[[
TBBlog >> writeBlogPost: aPost
   "Add the blog post to the list of posts."
   posts add: aPost
]]]

[[[
TBBlog >> size
   ^ posts size
]]]

The previous test should now pass (i.e. be green).
We should also add tests to cover all functionalities that we introduced.

!!!Increasing coverage
Ecrivons d'autres tests pour couvrir les fonctionnalités que nous venons de développer. 

[[[
TBBlogTest >> testSize
   self assert: blog size equals: 1
]]]

[[[
TBBlogTest >> testRemoveAllBlogPosts
   blog removeAllPosts.
   self assert: blog size equals: 0
]]]



!!! Other functionalities

!!!!Getting all the blog posts

Ajoutons un nouveau test qui échoue:

[[[
TBBlogTest >> testAllBlogPosts
   blog writeBlogPost: post.
   self assert: blog allBlogPosts size equals: 2
]]]

Et le code métier qui permet de le faire passer:

[[[
TBBlog >> allBlogPosts
   ^ posts
]]]


!!!!Obtenir tous les posts visibles

Test unitaire:

[[[
TBBlogTest >> testAllVisibleBlogPosts
   blog writeBlogPost: post.
   self assert: blog allVisibleBlogPosts size equals: 1
]]]

Code métier ajouté:

[[[
TBBlog >> allVisibleBlogPosts
   ^ posts select: [ :p | p isVisible ]
]]]


!!!!Obtenir tous les posts d'une catégorie

[[[
TBBlogTest >> testAllBlogPostsFromCategory
   self assert: (blog allBlogPostsFromCategory: 'First Category') size equals: 1
]]]

[[[
TBBlog >> allBlogPostsFromCategory: aCategory
   ^ posts select: [ :p | p category = aCategory ]
]]]

!!!!Obtenir tous les posts visibles d'une catégorie

[[[
TBBlogTest >> testAllVisibleBlogPostsFromCategory
   blog writeBlogPost: post.
   self assert: (blog allVisibleBlogPostsFromCategory: 'First Category') size equals: 0.
   self assert: (blog allVisibleBlogPostsFromCategory: 'Second Category') size equals: 1
]]]

[[[
TBBlog >> allVisibleBlogPostsFromCategory: aCategory
	^ posts select: [ :p | p category = aCategory 
									and: [ p isVisible ] ]
]]]

!!!!Vérifier la gestion des posts non classés

[[[
TBBlogTest >> testUnclassifiedBlogPosts
   self assert: (blog allBlogPosts select: [ :p | p isUnclassified ]) size equals: 0
]]]

!!!!Obtenir la liste des catégories

[[[
TBBlogTest >> testAllCategories
   blog writeBlogPost: post.
   self assert: blog allCategories size equals: 2
]]]

[[[
TBBlog >> allCategories
   ^ (self allBlogPosts collect: [ :p | p category ]) asSet
]]]

!!!Données de test 

Afin de nous aider à tester l'application nous définissons une méthode qui ajoute des posts au blog courant. 

[[[
TBBlog class >> createDemoPosts
   "TBBlog createDemoPosts"
   self current 
      writeBlogPost: ((TBPost title: 'Welcome in TinyBlog' text: 'TinyBlog is a small blog engine made with Pharo.' category: 'TinyBlog') visible: true);
      writeBlogPost: ((TBPost title: 'Report Pharo Sprint' text: 'Friday, June 12 there was a Pharo sprint / Moose dojo. It was a nice event with more than 15 motivated sprinters. With the help of candies, cakes and chocolate, huge work has been done' category: 'Pharo') visible: true);
      writeBlogPost: ((TBPost title: 'Brick on top of Bloc - Preview' text: 'We are happy to announce the first preview version of Brick, a new widget set created from scratch on top of Bloc. Brick is being developed primarily by Alex Syrel (together with Alain Plantec, Andrei Chis and myself), and the work is sponsored by ESUG. 
      Brick is part of the Glamorous Toolkit effort and will provide the basis for the new versions of the development tools.' category: 'Pharo') visible: true);
      writeBlogPost: ((TBPost title: 'The sad story of unclassified blog posts' text: 'So sad that I can read this.') visible: true);
      writeBlogPost: ((TBPost title: 'Working with Pharo on the Raspberry Pi' text: 'Hardware is getting cheaper and many new small devices like the famous Raspberry Pi provide new computation power that was one once only available on regular desktop computers.' category: 'Pharo') visible: true)
]]]

Vous pouvez inspecter le résultat de l'évaluation du code suivant :

[[[
	TBBlog createDemoPosts ; current
]]]

Attention, si vous exécutez plus d'une fois la méthode ==createDemoPosts==, le blog contiendra plusieurs exemplaires de ces posts.

!!! Futures évolutions

Plusieurs évolutions peuvent être apportées telles que: obtenir uniquement la liste des catégories contenant au moins un post visible, effacer une catégorie et les posts qu'elle contient, renommer une catégorie, déplacer un post d'une catégorie à une autre, rendre visible ou invisible une catégorie et son contenu, etc. Nous vous encourageons développer ces fonctionnalités ou de nouvelles que vous auriez imaginé.


!!! Conclusion

Vous devez avoir le modèle complet de TinyBlog ainsi que des tests unitaires associés. Vous êtes maintenant prêt pour des fonctionalités plus avancées comme le stockage ou un premier serveur HTTP. C'est aussi un bon moment pour sauver votre code dans votre dépôt en ligne.



