!!  TinyBlog Application: Core model
@cha:model
% full code at: 9c87f4b8abb956469e145d2ba8afeba8b66159d2

In this chapter, we start to develop a part of the domain model of TinyBlog.
The model is particularly simple: it starts with a post. 


!!! TBPost Class

We start with the post representation. It is defined by the class ==TBPost==:

[[[
Object subclass: #TBPost
   instanceVariableNames: 'title text date category visible'
   classVariableNames: ''
   package: 'TinyBlog'
]]]

A blog post is described by 5 instance variables.

|!Variable         |!Signification                       |
|==title==         |post title                           |
|==text==          |post text                            |
|==date==          |date of writing                      |
|==category==      |name of the category of the post     |
|==visible==       |is the post publicly visible or not? |

All of these variables have corresponding accessor methods in the 'accessing' protocol.
You can use a refactoring to automatically create all the following methods:

[[[
TBPost >> title
   ^ title
]]]
[[[
TBPost >> title: aString
   title := aString
]]]
[[[
TBPost >> text
   ^ text
]]]
[[[
TBPost >> text: aString
   text := aString
]]]
[[[
TBPost >> date
   ^ date
]]]
[[[
TBPost >> date: aDate
   date := aDate
]]]
[[[
TBPost >> visible
   ^ visible
]]]
[[[
TBPost >> visible: aBoolean
   visible := aBoolean
]]]
[[[
TBPost >> category
   ^ category
]]]
[[[
TBPost >> category: anObject
   category := anObject
]]]



!!!Post Visibility

We should add methods to make a post visible or not and also test if it is visible. Those methods are defined in the 'action' protocol.

[[[
TBPost >> beVisible
   self visible: true
]]]
[[[
TBPost >> notVisible
   self visible: false
]]]


!!!Initialization

The ==initialize== method ('initialization' protocol) sets the date to the current day and the visibility to false: the user must explicitly make a post visible. 
This allows him to write drafts and only publish when the post is finished.
By default, a post belongs to the 'Unclassified' category that we define at the class level.
This category name is defined on class-side by the ==unclassifiedTag== method.

[[[
TBPost class >> unclassifiedTag
   ^ 'Unclassified'
]]]

Pay attention the method ==unclassifiedTag== should be defined on the class-side of the class ==TBPost== (click on the ==class== button to define it). 
The other methods are defined on the instance-side: it means that they will be applied to ==TBBlog== instances. 

[[[
TBPost >> initialize
	super initialize.
	self category: TBPost unclassifiedTag.
	self date: Date today.
	self notVisible
]]]

In the solution above, it would be better that the ==initialize== method does not hard code the reference to the ==TBPost== class. 
Propose a solution.
The sequence 3 of the week 6 of the Mooc can help you to understand why it is better to avoid hardcoding class references (*http://rmod-pharo-mooc.lille.inria.fr/MOOC/WebPortal/co/content_67.html*).


!!!Posts creation methods

On class-side, we add methods to ease posts creation for blogs (in the protocol 'instance creation') that belong to a category or not.

[[[
TBPost class >> title: aTitle text: aText
   ^ self new
        title: aTitle;
        text: aText;
        yourself
]]]

[[[
TBPost class >> title: aTitle text: aText category: aCategory
   ^ (self title: aTitle text: aText)
            category: aCategory;
            yourself
]]]

!!!Post  creation

You can now create posts. Using the Playground tools execute the following expression:

[[[
TBPost 
	title: 'Welcome in TinyBlog' 
	text: 'TinyBlog is a small blog engine made with Pharo.' 
	category: 'TinyBlog'
]]]

When you inspect the code above (right click and "Inspect it"), you will obtain an inspector on the newly created object as shown in Figure *@inspectorOnTBPost*.

+Inspector on a TBPost instance.>figures/inspectorOnTBPost.png|width=100|label=inspectorOnTBPost+

!!! Adding some unit tests

Even though the model is quite simple we can define some tests.
In Test Driven Developpement mode we write test first. 
Here we prefered to let you define a little class to familiarize with the IDE. 
Let us fix this!

We define the class ==TBPPostTest== (as subclass of the class ==TestCase==).

[[[
TestCase subclass: #TBPostTest
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'TinyBlog-Tests'
]]]

[[[
TBPostTest >> testWithoutCategoryIsUnclassified

	| post |
	post := TBPost 
		title: 'Welcome to TinyBlog' 
		text: 'TinyBlog is a small blog engine made with Pharo.'.
	self assert: post title equals: 'Welcome to TinyBlog' .
	self assert: post category = TBPost unclassifiedTag.
]]]

[[[
TBPostTest >> testPostIsCreatedCorrectly

		| post |
		post := TBPost 
			title: 'Welcome to TinyBlog' 
			text: 'TinyBlog is a small blog engine made with Pharo.' 
			category: 'TinyBlog'.
		self assert: post title equals: 'Welcome to TinyBlog' .
		self assert: post text equals: 'TinyBlog is a small blog engine made with Pharo.' .
]]]

Your tests should pass.



!!! Post queries

In the protocol 'testing', define the following methods that checks whether a post is visible, and whether it is classified or not.

[[[
TBPost >> isVisible
   ^ self visible
]]]
[[[
TBPost >> isUnclassified
   ^ self category = TBPost unclassifiedTag
]]]

It is not really good to harcode a reference to the class ==TBPost== in a method body.
Propose a solution.

In addition, let us take the time to update our test for this new aspect.

[[[
TBPostTest >> testWithoutCategoryIsUnclassified

	| post |
	post := TBPost 
		title: 'Welcome to TinyBlog' 
		text: 'TinyBlog is a small blog engine made with Pharo.'.
	self assert: post title equals: 'Welcome to TinyBlog' .
	self assert: post isUnclassified.
	self deny: post isVisible
]]]



!!! Sauvegarder votre code 

Lorsque vous sauvez l'image Pharo (clic gauche sur le fond de Pharo pour accéder au menu world et sélectionner 'save'), celle-ci contient tous les objets du système et donc les classes elles-même.
Cette solution est pratique mais peu pérenne.  
Nous allons vous montrer comment les pharoers sauvent leur code sous forme de packages sur un serveur dédié à l'aide de Monticello: le gestionnaire de versions de Pharo.

Notez que des videos sont disponibles dans le Mooc Pharo qui montrent la procédure pour sauver du code: *http://mooc.pharo.org* et en particulier la video de la semaine 1 qui montre comment développer et sauver le code d'une application compteur: *http://rmod-pharo-mooc.lille.inria.fr/MOOC/Videos/W1/C019-W1S-Videos-Redo-Counter-Traditional-FR-V3-HD_720p_4Mbs.m4v*.

!!!!Créer un dépôt de code

Il existent plusieurs serveurs en ligne permettant d'héberger vos dépôts de code gratuitement comme Smalltalkhub *http://smalltalkhub.com* ou SS3 *http://ss3.gemstone.com*. 

- Créer un compte sur le site  *http://smalltalkhub.com/*.
- Se connecter au site. 
- Créer un projet nommé "TinyBlog" (si vous rencontrez des problèmes de connexion car le site est en version beta, essayez avec un autre navigateur ; si les problèmes persistent utilisez *http://ss3.gemstone.com*).

!!!!Sauver votre package

- Dans Pharo, ouvrez l'outil Monticello Browser via le menu principal (clic gauche sur le fond de Pharo).
- Ajoutez un dépôt (repository) de type SmalltalkHub ou HTTP pour *http://ss3.gemstone.com*.
- Sélectionnez ce dépôt et dans son menu contextuel (clic droit), sélectionnez l'item 'Add to package...' pour ajouter ce dépôt au package TinyBlog.
- Sélectionnez maintenant votre package et pressez le bouton 'Save'. 
- Indiquez une description pour votre commit et sauver. Votre code vient d'être envoyé sur le serveur.

Le code de votre application TinyBlog est maintenant sauvegardé dans votre dépôt sur Smalltalkhub. Il est donc maintenant possible de charger votre code dans une nouvelle image Pharo. 
Pour rappel, dans le cadre de ce tutoriel, nous vous suggérons de toujours utiliser l'image avec tous les packages web chargés que nous avons mentionné dans le premier chapitre. Cela vous permettra de pouvoir recharger votre package sans devoir vous soucier des dépendances sur d'autres packages. 


!!!A propos de dépendances

Les bonnes pratiques lors de développements en Pharo sont de spécifier clairement les dépendances sur les packages utilisés afin d'avoir une reproductibilité complète d'un projet. Une telle reproductibilité permet alors l'utilisation de serveur de construction tels que Travis ou Jenkins.
Pour cela, une configuration (une classe spéciale) définit d'une part l'architecture du projet (dépendances et packages du projet) et les versions des packages versionnés. 

Dans le cadre de ce projet, nous n'abordons pas ce point plus avancé. Un chapitre entier est consacré à l'expression de configurations dans le livre intitulé "Deep Into Pharo" (cf. *http://books.pharo.org*). 
 
%!!!!! Optionel. 
%Si vous voulez essayer de créer une configuration, vous pouvez utiliser Versionner. 
%Dans votre image Pharo, ouvrez l'outil Versionner depuis le menu 'Tools':
%%- Créez un nouveau projet nommé "TinyBlog",
%- Indiquez que votre projet dépend de PharoWeb (dépendance entre projets),
%- Dans Packages, ajoutez le paquet TinyBlog,
%- Définissez le dépôt de votre projet: 'http://smalltalkhub.com/mc/XXX/TinyBlog/main'
%- Cliquez sur le bouton "Save to development" (pour générer la nouvelle structure %d'architecture et dépendances), "Release" (pour créer une nouvelle vetsion) et Commit (pour sauver le code sur le serveur).


!!! Conclusion

Nous avons développé une première partie du modèle (la classe ==TBPost==) et défini quelques tests. Nous vous suggérons fortement 
d'écrire d'autres tests unitaires pour vérifier que ce modèle fonctionne correctement même s'il est simple.
